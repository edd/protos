syntax = "proto3";

option go_package = "code.vegaprotocol.io/protos/vega/api";

import "vega/vega.proto";
import "vega/markets.proto";
import "vega/governance.proto";
import "vega/assets.proto";
import "vega/events/v1/events.proto";
import "vega/oracles/v1/spec.proto";
import "vega/oracles/v1/data.proto";
import "vega/commands/v1/commands.proto";
import "vega/commands/v1/transaction.proto";
import "vega/commands/v1/validator_commands.proto";

package api.v1;

import "github.com/mwitkow/go-proto-validators/validator.proto";

service TradingService {
  // Submit a signed transaction (v2)
  rpc SubmitTransactionV2(SubmitTransactionV2Request) returns (SubmitTransactionV2Response);
  // Propagate a chain event
  rpc PropagateChainEvent(PropagateChainEventRequest) returns (PropagateChainEventResponse);
  // Get Statistics on Vega
  rpc Statistics(StatisticsRequest) returns (StatisticsResponse);
  // Get the height of the last tendermint block
  rpc LastBlockHeight(LastBlockHeightRequest) returns (LastBlockHeightResponse);
  // Get Time
  rpc GetVegaTime(GetVegaTimeRequest) returns (GetVegaTimeResponse);
}

// Request for a new event sent by the blockchain queue to be propagated on Vega
message PropagateChainEventRequest {
  // Chain event
  bytes event = 1;
  // Public key
  string pub_key = 2;
  // Signature
  bytes signature = 3;
}

// Response for a new event sent by the blockchain queue to be propagated on Vega
message PropagateChainEventResponse {
  // Success will be true if the event was accepted by the node,
  // **Important** - success does not mean that the event is confirmed by consensus
  bool success = 1;
}

// Request for submitting a transaction v2 on Vega
message SubmitTransactionV2Request {
  // Blockchain transaction type
  enum Type {
    TYPE_UNSPECIFIED = 0;
    // The transaction will be submitted without waiting for response
    TYPE_ASYNC = 1;
    // The transaction will be submitted, and blocking until the
    // tendermint mempool return a response
    TYPE_SYNC = 2;
    // The transaction will submitted, and blocking until the tendermint
    // network will have committed it into a block
    TYPE_COMMIT = 3;
  }

  // A bundle of signed payload and signature, to form a transaction that will be submitted to the Vega blockchain
  vega.commands.v1.Transaction tx = 1;
  // Type of transaction request, for example ASYNC, meaning the transaction will be submitted and not block on a response
  Type type = 2;
}

// Response for submitting a transaction v2 on Vega
message SubmitTransactionV2Response {
  // Success will be true if the transaction was accepted by the node,
  // **Important** - success does not mean that the event is confirmed by consensus
  bool success = 1;
}


// Request for the current time of the vega network
message GetVegaTimeRequest {}

// Response for the current consensus coordinated time on the Vega network, referred to as "VegaTime"
message GetVegaTimeResponse {
  // Timestamp representation of current VegaTime as represented in
  // Nanoseconds since the epoch, for example `1580473859111222333` corresponds to `2020-01-31T12:30:59.111222333Z`
  int64 timestamp = 1;
}

// Request to subscribe to a stream of one or more event types from the Vega event bus
message ObserveEventBusRequest {
  // One or more types of event, required field
  repeated vega.events.v1.BusEventType type = 1;
  // Market identifier, optional field
  string market_id = 2;
  // Party identifier, optional field
  string party_id = 3;
  // Batch size, optional field -
  // If not specified, any events received will be sent immediately. If the client is not ready
  // for the next data-set, data may be dropped a number of times, and eventually the stream is closed.
  // if specified, the first batch will be sent when ready. To receive the next set of events, the client
  // must write an `ObserveEventBatch` message on the stream to flush the buffer.
  // If no message is received in 5 seconds, the stream is closed.
  // Default: 0, send any and all events when they are available.
  int64 batch_size = 4;
}

// Response to a subscribed stream of events from the Vega event bus
message ObserveEventBusResponse {
  // One or more events
  repeated vega.events.v1.BusEvent events = 1;
}

// A a request for statistics about the Vega network
message StatisticsRequest {}

message StatisticsResponse {
  vega.Statistics statistics = 1;
}

// A request to get the height of the very last block processed
// by tendermint
message LastBlockHeightRequest {}

// A response with the height of the last block processed by
// tendermint
message LastBlockHeightResponse {
  uint64 height = 1;
}
